<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>my blog</title>
  <link rel="alternate" type="application/rss+xml"
   href="feed.rss" title="RSS feed for My Page">
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
	body {
		margin : 0;
		max-width : none; 
	}
	h1 {
		text-align : center;
		min-width:200px;max-width:900px;margin:0 auto;padding:15px
	}	
	h2 {
		text-align : center;
		min-width:200px;max-width:900px;margin:0 auto;padding:15px
	}	
	h3 {
		text-align : center;
		min-width:200px;max-width:900px;margin:0 auto;padding:15px
	}
	p {
		text-align : justify;
		min-width:200px;max-width:900px;margin:0 auto;padding:15px
	}	
	li {
		text-align : left;
		min-width:200px;max-width:900px;margin:0 auto;padding:15px
	}
	pre {
		text-align : left;
		min-width:200px;max-width:900px;margin:0 auto;padding:15px
	}
	div.sourceCode {
		text-align : left;
		min-width:200px;max-width:900px;margin:0 auto;padding:15px
	}
	#HME {
		text-decoration : none;
		float : left;
	}
	#LNK {
		text-decoration : none;
		float : right;
	}
	#NCE {
		text-decoration-line : underline;
		text-decoration-color : blue;
		color : blue;
	}
	img {
		width:70%;max-width:900px;padding:5px
	}
	a {
		text-decoration : none;
		color : black;
	}
	a:visited {
		text-decoration : none;
		color : black;
	}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<a id = "LNK" 
	href = bloglight.html>üè†</a>
<a id = "LNK" 
	href = 2021-01-31_gen_dark.html>üåò</a>
<br/>
<header id="title-block-header">
<h1 class="title">my blog</h1>
<p class="author"><center>
<a href="mailto:kacpertopol@gmail.com">kacper topolnicki</a></br><a href="mailto:kacpertopol@gmail.com">kacpertopol@gmail.com</a>
<center></p>
</header>
<h1 id="monads-and-do-notation-in-the-wolfram-language-part-1">monads and ‚Äúdo‚Äù notation in the <em>Wolfram Language</em>, part 1</h1>
<center>
<em>2021-01-31</em>
</center>
<p>motivation, categorical interpretation of the <em>Wolfram Language</em> ‚Ä¶</p>
<p>This is the first part of a series of posts that introduce ‚Äúdo‚Äù notation to the <em>Wolfram Language</em>. There are many ways of doing this. I will be using an approach described in my <a id = "NCE" href = https://arxiv.org/abs/2005.09478>article</a> on <em>arXiv</em>, these posts will be slightly edited versions of section from that paper.</p>
<p>The motivation for this work stems from a practical problem of writing a <em>Wolfram Language</em> (WL) application aimed to abstract away the notion of scalar valued functions for numerical computations. The goal was for the user to specify, in the WL, the number of arguments for a function, which arguments are discrete indices and which arguments are floating point numbers. For floating point arguments the user additionally defines points and weights used for interpolations and integrations over these arguments and finally specifies which arguments can be used for purposes of code parallelization. Given this input, the job of the application is to create a <em>FORTRAN 90</em> module and a directory with supplementary data. The user can import this module and work with an abstraction of the scalar valued functions: store function values on different cores and handle them using different <em>MPI</em> and <em>OPENMP</em> threads, interpolate function values and integrate over function arguments.</p>
<p>The implementation works, more or less :-) Basing the implementation around monadic types was really helpful. The monadic style of programming can also be appropriate for many other problems. Here a simple approach to include monads and the <em>Haskell</em> style "do" notation in the WL is proposed. This combined with the powerful functions built into the <em>Mathematica</em> system can lead to the production of very powerful code.</p>
<p>This work was influenced by an excellent <a id = "NCE" href = https://www.blurb.com/b/9621951-category-theory-for-programmers-new-edition-hardco>book</a> by Bartosz Milewski containing an introduction to Category Theory. First, in this post, a categorical interpretation of the WL is introduced. In the next post the implementation of monadic types and the ‚Äúdo‚Äù notation will be described. Further posts will contain examples and tips for practical implementations. The text contains snippets of WL code and pseudo-code. Some code fragments will use comments <code>(*...*)</code> to hold additional information intended for interpretation by the reader.</p>
<p>In order to think about the WL as a category a subset of the WL will be considered consisting of functions defined in the following manner:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode mathematica"><code class="sourceCode mathematica"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>    <span class="fu">f</span><span class="op">[</span><span class="co">(*pattern a*)</span><span class="op">]</span> <span class="ex">:=</span> <span class="co">(*expression*)</span></span></code></pre></div>
<p>where <em>f</em> stands for the function name (other symbols can also be used), <em>pattern a</em> is a WL language pattern expression that specifies the arguments accepted by the function <em>f</em> and <em>expression</em> is a WL expression that can be constructed from the named parts of <em>pattern a</em>. This is not directly enforced by the WL, but ideally all possible results of <em>f</em> match a different pattern, <em>pattern b</em>, so that:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode mathematica"><code class="sourceCode mathematica"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>    <span class="fu">MatchQ</span><span class="op">[</span><span class="fu">f</span><span class="op">[</span><span class="co">(*expression matching pattern a*)</span><span class="op">],</span><span class="co">(*pattern b*)</span><span class="op">]</span></span></code></pre></div>
<p>is always true. Curried functions can be used and this can be interpreted as replacing <code>f</code> with <code>f[x]</code>, <code>f[x][y]</code>, ‚Ä¶ in the pseudo code above and treating the replacement as a whole set of functions built from the different values of <code>x</code>, <code>y</code>, ‚Ä¶</p>
<p>It is seems natural to treat this subset of the WL as a category with morphisms being functions (e.g.¬†<code>f</code>, <code>f[x]</code>, <code>f[x][y]</code>, ‚Ä¶) and objects being types defined by WL patterns (e.g.¬†the set of all WL expressions that match <em>pattern a</em> defines type <em>a</em> and the set of expressions that match <em>pattern b</em> defines type <em>b</em>). In this context a monad is a type function: it takes a pattern that defines one type and returns a new pattern that defines a different type. Some additional definitions are necessary and they discussed next time.</p>
<br/>
<a id = "LNK" 
   href = "feed.rss"><img src = "Feed-icon.svg" height = 14em></a>
</body>
</html>
